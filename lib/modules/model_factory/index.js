'use strict'

const Async = require('async')

/**
 * Creates fake instance(s) of the model given by the `model`
 * argument and hydrates the instance(s) with data generated by calling
 * the `data` argument. Each call to `data` is expected to generate
 * unique hydration data.
 */
function ModelFactory(model, data) {
  this.model = model
  this.data = data
  this.injectionData = null
}

/**
 * Generates fake data that are used to instantiate and hydrate
 * the model object. Calls `onDataGenerated` when done.
 */
ModelFactory.prototype.generateDataJson = function(onDataGenerated) {
  this.data((d) => {
    return onDataGenerated(null, d)
  })
}

ModelFactory.prototype.dearrayIfLengthEqualsOne = function(items, done) {
  if (items.length > 1) {
    return done(null, items)
  }
  else {
    return done(null, items[0])
  }
}

/**
 * Creates a fake model object and returns it. It does not persist
 * the object in the database. Calls `done` when done.
 */
ModelFactory.prototype.create = function(count, injectionData, done) {
  var _this = this
  this.injectionData = injectionData

  Async.waterfall([
    prepAsyncMakeModelCalls,
    Async.parallel,
    _this.dearrayIfLengthEqualsOne
  ],
  (err, models) => {
    if (err) {
      return done(err, null)
    }

    return done(err, models)
  })

  function prepAsyncMakeModelCalls(done) {
    var calls = []

    for (var i = 0; i < count; i++) {
      calls.push(function(callback) {
        makeModel((err, model) => {
          callback(err, model)
        })
      })
    }

    return done(null, calls)
  }

  function makeModel(done) {
    Async.waterfall([
      function(callback) {
        return _this.generateDataJson(callback)
      },
      function(data, callback) {
        return injectData(data, callback)
      },
      function(data, callback) {
        return validateData(data, callback)
      }
    ], (err, model) => {
      return done(err, model)
    })
  }

  function injectData(data, done) {
    var err = null

    for (var key in _this.injectionData) {
      // if (data.hasOwnProperty(key)) {
      data[key] = _this.injectionData[key]
      // }
      // else {
      //   err = new Error('Injection data key "' + key +
      //     '" not found in the object ' +
      //     'that is being injected into.')
      // }
    }

    return done(err, data)
  }

  function validateData(data, done) {
    var Model = _this.model
    var model = new Model(data)

    model.joiValidate(data, Model.validationSchema, (err) => {
      return done(err, model)
    })
  }

}

/**
 * Creates a fake model object and persists it in the database.
 * When done persisting, calls the `done` callback.
 */
ModelFactory.prototype.createAndSave = function(count, injectionData, done) {
  var _this = this
  this.injectionData = injectionData

  return this.create(count, injectionData, persistModels)

  function persistModels(err, models) {
    if (err) {
      return done(err, null)
    }
    Async.waterfall([
      Async.apply(ensureIsArray, models),
      prepAsyncSaveCalls,
      Async.parallel,
      _this.dearrayIfLengthEqualsOne
    ],
    (err, models) => {
      if (err) {
        return done(err, null)
      }

      return done(err, models)
    })

    function prepAsyncSaveCalls(models, done) {
      var calls = []

      models.forEach(function buildSaveCallsArray(model) {
        calls.push(function(callback) {
          model.save((err, model) => {
            callback(err, model)
          })
        })
      })

      return done(null, calls)
    }

    function ensureIsArray(models, done) {
      if (!Array.isArray(models)) {
        models = [models]
      }

      return done(null, models)
    }
  }
}

module.exports = ModelFactory
